use std::{
    fs::File,
    io::{Read, Write},
    path::Path,
};

use cargo_lock::Lockfile;
use cargo_toml::Manifest;
use petgraph::visit::Bfs;

const DEFAULT_RULES: &str = r#"# Rules generated by bygge. DO NOT MODIFY BY HAND!
extraargs = --cap-lints allow -C debuginfo=2

rule cargo-fetch
  command = cargo fetch --manifest-path $in && touch $out
  description = CARGO $in

rule rustc
  command = rustc --crate-name $name $in --emit=$emit --out-dir $outdir $extraargs $args && sed -i '' '/\.d:/g' $depfile
  description = RUSTC $out
  depfile = $depfile
  deps = gcc

build Cargo.lock: cargo-fetch Cargo.toml
"#;

const REGISTRY_PATH: &str = "/Users/jrediger/.cargo/registry/src/github.com-1ecc6299db9ec823";

#[derive(Debug)]
struct Args {
    help: bool,
    version: bool,
    manifest_path: String,
    lockfile: String,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = pico_args::Arguments::from_env();

    // Arguments can be parsed in any order.
    let args = Args {
        // You can use a slice for multiple commands
        help: args.contains(["-h", "--help"]),
        // or just a string for a single one.
        version: args.contains("-V"),
        // Path to Cargo.toml
        manifest_path: args
            .opt_value_from_str(["-p", "--manifest-path"])?
            .unwrap_or_else(|| "Cargo.toml".into()),
        // Path to Cargo.lock
        lockfile: args
            .opt_value_from_str(["-l", "--lockfile"])?
            .unwrap_or_else(|| "Cargo.lock".into()),
    };

    let mut rules = File::create("build.ninja")?;
    writeln!(rules, "{}", DEFAULT_RULES)?;

    let lockfile = Lockfile::load(&args.lockfile)?;

    let manifest = Manifest::from_path(&args.manifest_path)?;
    let package = manifest.package.unwrap();
    let pkg_name = package.name;

    let root_package = lockfile
        .packages
        .iter()
        .find(|pkg| pkg.name.as_str() == pkg_name)
        .unwrap();

    let tree = lockfile.dependency_tree()?;
    let nodes = tree.nodes();
    let graph = tree.graph();

    let (_, &root_idx) = nodes
        .iter()
        .find(|(dep, _)| dep.matches(root_package))
        .unwrap();

    let mut bfs = Bfs::new(&graph, root_idx);
    while let Some(nx) = bfs.next(&graph) {
        let node = &graph[nx];
        let pkg_name = node.name.as_str();
        let norm_pkg_name = normalize_crate_name(pkg_name);

        if nx == root_idx {
            write!(
                rules,
                "build build/{}: rustc src/main.rs | Cargo.lock ",
                norm_pkg_name
            )?;
            for dep in &node.dependencies {
                write!(
                    rules,
                    "build/deps/lib{}.rlib ",
                    normalize_crate_name(dep.name.as_str())
                )?;
            }

            writeln!(rules)?;
            writeln!(rules, "  name = {} ", norm_pkg_name)?;
            write!(
                rules,
                "  args = --crate-type bin --edition 2018 -L dependency=build/deps "
            )?;
            for dep in &node.dependencies {
                if skip_dep(dep.name.as_str()) {
                    continue;
                }
                write!(
                    rules,
                    "--extern {}=build/deps/lib{}.rlib ",
                    normalize_crate_name(dep.name.as_str()),
                    normalize_crate_name(dep.name.as_str())
                )?;
            }
            writeln!(rules)?;
            writeln!(rules, "  outdir = build/")?;
            writeln!(rules, "  emit = dep-info,link")?;
            writeln!(rules, "  depfile = build/{}.d", norm_pkg_name)?;
            writeln!(rules)?;

            writeln!(rules, "default build/{}", norm_pkg_name)?;
        } else {
            if skip_dep(pkg_name) {
                continue;
            }
            let crate_path = Path::new(REGISTRY_PATH).join(&format!(
                "{pkg}-{version}",
                pkg = pkg_name,
                version = node.version
            ));
            let toml_path = crate_path.join("Cargo.toml");
            let mut f = File::open(&toml_path)?;
            let mut buffer = Vec::new();
            f.read_to_end(&mut buffer)?;
            let manifest = Manifest::from_slice(&buffer)?;
            let entry = manifest
                .lib
                .and_then(|lib| lib.path)
                .unwrap_or_else(|| "src/lib.rs".into());
            let entry_path = crate_path.join(entry);

            write!(
                rules,
                "build build/deps/lib{pkg}.rlib build/deps/lib{pkg}.rmeta: rustc {entry_path} | ",
                pkg = norm_pkg_name,
                entry_path = entry_path.display()
            )?;
            for dep in &node.dependencies {
                if skip_dep(dep.name.as_str()) {
                    continue;
                }
                write!(
                    rules,
                    "build/deps/lib{}.rlib ",
                    normalize_crate_name(dep.name.as_str()),
                )?;
            }
            writeln!(rules)?;
            writeln!(rules, "  name = {} ", norm_pkg_name)?;
            write!(rules, "  args = --crate-type lib -L dependency=build/deps ")?;
            write!(
                rules,
                "--edition {} ",
                edition(manifest.package.unwrap().edition)
            )?;
            if norm_pkg_name == "libc" {
                write!(
                    rules,
                    r#"--cfg 'feature="default"' --cfg 'feature="extra_traits"' --cfg 'feature="std"' --cfg freebsd11 --cfg libc_priv_mod_use --cfg libc_union --cfg libc_const_size_of --cfg libc_align --cfg libc_core_cvoid --cfg libc_packedN "#
                )?;
            }
            for dep in &node.dependencies {
                if skip_dep(dep.name.as_str()) {
                    continue;
                }
                write!(
                    rules,
                    "--extern {}=build/deps/lib{}.rmeta ",
                    normalize_crate_name(dep.name.as_str()),
                    normalize_crate_name(dep.name.as_str())
                )?;
            }
            writeln!(rules)?;
            writeln!(rules, "  outdir = build/deps/")?;
            writeln!(rules, "  emit = dep-info,metadata,link")?;
            writeln!(rules, "  depfile = build/deps/{}.d", norm_pkg_name)?;
            writeln!(rules)?;
        }
    }

    Ok(())
}

fn normalize_crate_name(crate_name: &str) -> String {
    crate_name.replace('-', "_")
}

fn edition(ed: cargo_toml::Edition) -> &'static str {
    use cargo_toml::Edition::*;
    match ed {
        E2018 => "2018",
        _ => "2015",
    }
}

fn skip_dep(name: &str) -> bool {
    name.contains("winapi") || name.contains("redox")
}
